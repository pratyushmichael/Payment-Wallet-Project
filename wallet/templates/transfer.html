<!-- Create a UI Form for Transfer -->

<!-- wallet/templates/transfer.html -->
<h2>Transfer Money</h2>

<!-- NEW: Add this line under heading -->
<p><a href="{% url 'wallet_home' %}">⬅️ Back to Dashboard</a></p>

<!-- Show error messages (e.g., insufficient balance) -->
{% if error %}
  <p style="color:red;">{{ error }}</p>
{% endif %}

<!-- method POST: send data in request body; action posts to /transfer/ route by name -->
<form method="POST" action="{% url 'transfer_money' %}">
  {% csrf_token %}
   
  <!-- Django adds a hidden anti-forgery token to the form.
       Django’s middleware checks this token on POST to prevent cross-site request forgery.
       Without this, Django will reject the request with a 403 error -->


   <!--Every form render already has a unique CSRF token
        We reuse it as our idempotency key-->
  <input type="hidden" name="reference_id" value="{{ csrf_token }}">


  <!-- Username input with datalist for suggestions -->
  <label>Send To (username):</label>
  <input type="text" name="receiver" list="users" required>

  <!-- datalist provides a dropdown of existing usernames; user can also type freely -->
  <datalist id="users">
    {% for u in users %}
      <option value="{{ u.username }}">
    {% endfor %}
  </datalist>

  <br><br>

  <!-- Numeric amount (2 decimals) -->
  <label>Amount:</label>
  <input type="number" step="0.01" name="amount" required>

  <br><br>

  <!-- Submit button -->
  <button type="submit">Send Money</button>
</form>

<!--name="receiver" and name="amount"
these become the keys in request.POST on the server side.
In views.py we read them as =>
    receiver_username = request.POST.get("receiver")
    amount = Decimal(request.POST.get("amount")) -->
    
   
